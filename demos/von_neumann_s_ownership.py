# -*- coding: utf-8 -*-
"""Viper Stack v5.9: von Neumann S Fork for VOW "Ownership".ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tu-xDGcKFMqWlF5hRM-PhKohL8_hDkNo
"""

# VOW "Ownership" Hybrid: von Neumann S(ρ) Tuner — v6.0 Fork (Bell Entangled)
import qutip as qt
import numpy as np

noise = 0.1
n_seeds = 10
hybrid_mutual = 0.7  # 70% Nash mutual
hybrid_individual = 0.3  # 30% Stackelberg individual

S_list = []
H_list = []
I_list = []
uplifts = []

for seed in range(n_seeds):
    np.random.seed(seed)
    # Maximally entangled Bell state for stable I(A:B)=1.0
    bell = (qt.tensor(qt.basis(2,0), qt.basis(2,0)) + qt.tensor(qt.basis(2,1), qt.basis(2,1))).unit() / np.sqrt(2)
    rho = qt.ket2dm(bell)
    rho.dims = [[2,2],[2,2]]

    # Depolarizing noise
    p_depol = noise
    rho_random = qt.rand_dm(4)
    rho_random.dims = rho.dims
    rho_noisy = (1 - p_depol) * rho + p_depol * rho_random

    # Von Neumann S
    S_rho = qt.entropy_vn(rho_noisy)

    # Classical H
    p_diag = np.diag(rho_noisy.full())
    H_equiv = -np.sum(p_diag * np.log2(p_diag + 1e-10)).real

    # Mutual info
    S_A = qt.entropy_vn(rho_noisy.ptrace(0))
    S_B = qt.entropy_vn(rho_noisy.ptrace(1))
    I_AB = S_A + S_B - S_rho

    # Hybrid uplift: 70% mutual (I(A:B)) + 30% individual (S(ρ) - H)
    uplift_mutual = ((I_AB - H_equiv) / H_equiv) * hybrid_mutual * 100 if H_equiv != 0 else 0
    uplift_individual = ((S_rho - H_equiv) / H_equiv) * hybrid_individual * 100 if H_equiv != 0 else 0
    uplift_total = uplift_mutual + uplift_individual

    S_list.append(S_rho)
    H_list.append(H_equiv)
    I_list.append(I_AB)
    uplifts.append(uplift_total)

print(f"VOW 'Ownership' Hybrid: Average S(ρ) = {np.mean(S_list):.3f} bits (H equiv = {np.mean(H_list):.3f})")
print(f"Average I(A:B) = {np.mean(I_list):.3f} bits — hybrid uplift {np.mean(uplifts):.2f}% under σ={noise}")
print("70% mutual Nash + 30% individual Stackelberg: value flows pruned, swarm breathes sovereign.")