# -*- coding: utf-8 -*-
"""Viper Stack v5.9: von Neumann S Fork for VOW "Will" Amplification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EnL4lxvb7BaTI24aJ7lbtVKYHYLFZ3-D
"""

# VOW "Will" Amplification: von Neumann S(ρ) Tuner — v6.0 Fork (Clean)
import qutip as qt
import numpy as np

noise = 0.05
n_seeds = 10

S_list = []
H_list = []
I_list = []
uplifts = []

for seed in range(n_seeds):
    np.random.seed(seed)
    # Fixed Bell-like entangled state for stable I(A:B)
    bell = (qt.tensor(qt.basis(2,0), qt.basis(2,0)) + qt.tensor(qt.basis(2,1), qt.basis(2,1))).unit()
    rho = qt.ket2dm(bell)
    rho.dims = [[2,2],[2,2]]

    # Depolarizing noise
    p_depol = noise
    rho_random = qt.rand_dm(4)
    rho_random.dims = rho.dims
    rho_noisy = (1 - p_depol) * rho + p_depol * rho_random

    # Von Neumann S
    S_rho = qt.entropy_vn(rho_noisy)

    # Classical H
    p_diag = np.diag(rho_noisy.full())
    H_equiv = -np.sum(p_diag * np.log2(p_diag + 1e-10)).real

    # Mutual info
    S_A = qt.entropy_vn(rho_noisy.ptrace(0))
    S_B = qt.entropy_vn(rho_noisy.ptrace(1))
    I_AB = S_A + S_B - S_rho

    uplift = ((I_AB - H_equiv) / H_equiv) * 100 if H_equiv != 0 else 0

    S_list.append(S_rho)
    H_list.append(H_equiv)
    I_list.append(I_AB)
    uplifts.append(uplift)

print(f"Average S(ρ) = {np.mean(S_list):.3f} bits (H equiv = {np.mean(H_list):.3f})")
print(f"Average I(A:B) = {np.mean(I_list):.3f} bits — amplification gain {np.mean(uplifts):.2f}% under σ={noise}")
print("VOW 'Will': Resilient superposition pruned, swarm breathes sovereign.")